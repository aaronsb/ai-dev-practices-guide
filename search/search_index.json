{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AI Coding Agent Practices","text":"<p>Welcome to the AI Coding Agent Practices documentation. This site provides guidance on common antipatterns and best practices when working with AI coding assistants.</p>"},{"location":"#what-youll-find-here","title":"What You'll Find Here","text":"<p>This documentation is organized into two main sections:</p>"},{"location":"#antipatterns","title":"Antipatterns","text":"<p>Common problematic patterns to watch for when working with AI coding assistants, and practical strategies to address them:</p> <ul> <li>Premature Architecture Complexity</li> <li>Test-Driven Design Misapplication</li> <li>Purpose Drift During Refactoring</li> <li>Library and Framework Reinvention</li> <li>Failure to Separate Concerns</li> </ul>"},{"location":"#best-practices","title":"Best Practices","text":"<p>Guidelines and patterns for effective AI-assisted coding:</p> <ul> <li>Managing Code Complexity</li> <li>Factory Pattern Implementation</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>If you're new to working with AI coding assistants, we recommend starting with the Antipatterns Overview to understand common pitfalls, followed by the best practices section to learn effective strategies for AI collaboration.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>This is a living document. If you have suggestions for improvements or additional patterns to document, please feel free to contribute by submitting a pull request to our GitHub repository.</p>"},{"location":"antipatterns/","title":"AI Coding Assistant Antipatterns","text":"<p>Common problematic patterns to watch for when working with AI coding assistants, and practical strategies to address them.</p>"},{"location":"antipatterns/#quick-reference-guide","title":"Quick Reference Guide","text":"<ol> <li> <p>Premature Architecture Complexity - Creating overly complex architectures before requirements are clear</p> </li> <li> <p>Test-Driven Design Misapplication - Following test patterns blindly instead of designing from first principles</p> </li> <li> <p>Purpose Drift During Refactoring - Losing sight of original goals during continuous refactoring</p> </li> <li> <p>Library and Framework Reinvention - Reimplementing functionality already available in established libraries</p> </li> <li> <p>Failure to Separate Concerns - Mixing different responsibilities within the same components</p> </li> </ol>"},{"location":"antipatterns/#general-strategies","title":"General Strategies","text":"<p>When working with AI coding assistants:</p> <p>While each antipattern has specific remediation approaches, several general strategies apply across all patterns:</p> <ol> <li>Start with clear requirements and constraints</li> <li>Be explicit about what is needed and what isn't</li> <li> <p>Define scope boundaries before discussing architecture</p> </li> <li> <p>Focus on incremental development</p> </li> <li>Begin with minimal solutions and build up as needed</li> <li> <p>Validate each step before adding complexity</p> </li> <li> <p>Establish regular check-in points</p> </li> <li>Reconnect to original goals frequently</li> <li> <p>Verify that current direction aligns with requirements</p> </li> <li> <p>Challenge complexity</p> </li> <li>Ask for justification of complex components</li> <li> <p>Request simpler alternatives when appropriate</p> </li> <li> <p>Leverage existing tools</p> </li> <li>Start with available libraries and frameworks</li> <li>Question custom implementations of solved problems</li> </ol>"},{"location":"antipatterns/#how-to-use-these-guides","title":"How to Use These Guides","text":"<ul> <li>Reference a specific antipattern when you detect it</li> <li>Apply the suggested interventions to redirect the AI assistant</li> <li>Use the preventive measures when starting new projects</li> <li>Add your own observations and successful strategies</li> </ul>"},{"location":"antipatterns/library-reinvention/","title":"Library and Framework Reinvention","text":"<p>When AI assistants implement custom solutions for problems that already have established, well-tested libraries or frameworks. Instead of leveraging existing tools, they create novel implementations that duplicate available functionality, causing unnecessary complexity and potential reliability issues.</p>"},{"location":"antipatterns/library-reinvention/#how-to-spot-it","title":"How to Spot It","text":"<p>Look for these signs:</p> <ul> <li>Lengthy custom implementations of common functionality (authentication, validation, etc.)</li> <li>Phrases like \"let's create our own X\" without justifying why existing solutions are inadequate</li> <li>Absence of import statements for standard libraries that would solve the problem</li> <li>Complex utility functions that replicate standard library features</li> <li>Implementing low-level functionality (HTTP clients, JSON parsing, etc.) from scratch</li> <li>Detailed explanations of algorithms that exist in standard libraries</li> <li>No mention of established packages when proposing solutions in domains with clear standards</li> </ul>"},{"location":"antipatterns/library-reinvention/#why-its-harmful","title":"Why It's Harmful","text":"<ul> <li>Creates maintenance burden for custom code</li> <li>Misses security features and edge case handling present in established libraries</li> <li>Wastes time reinventing solutions to already-solved problems</li> <li>Extends development time</li> <li>Produces inconsistent behavior compared to standard implementations</li> <li>Generates technical debt from non-standard approaches</li> </ul>"},{"location":"antipatterns/library-reinvention/#what-to-do-about-it","title":"What to Do About It","text":"<p>When you see this happening:</p> <ol> <li>Ask \"Is there an existing library or framework that handles this for us?\"</li> <li>Request \"What established libraries could we use instead of building this ourselves?\"</li> <li>Question \"What are the tradeoffs between your custom implementation and using library X?\"</li> <li>Challenge \"Why are we building this from scratch rather than using existing tools?\"</li> </ol> <p>To prevent it next time:</p> <ol> <li>Start with discovery: \"What libraries are commonly used for this type of problem?\"</li> <li>Set expectations: \"Our default approach is to use existing libraries unless there's a compelling reason not to.\"</li> <li>Request library-first solutions: \"Please suggest solutions that leverage established libraries first.\"</li> <li>Define boundaries: \"We only want custom implementations for X, Y, and Z; everything else should use standard libraries.\"</li> <li>Require justification: \"If suggesting a custom implementation, explain why existing libraries don't meet our needs.\"</li> </ol>"},{"location":"antipatterns/library-reinvention/#example","title":"Example","text":"<p>AI: \"For handling HTTP requests, we'll create a custom HttpClient class that manages connections and handles different content types. Here's the implementation...\"</p> <p>You: \"Let's use Axios (or fetch in a browser environment) instead of writing our own HTTP client. Can you revise the approach to leverage that established library?\"</p>"},{"location":"antipatterns/library-reinvention/#benefits-of-fixing-this","title":"Benefits of Fixing This","text":"<ul> <li>Reduces development time and effort</li> <li>Creates more reliable and secure solutions</li> <li>Makes onboarding easier for developers familiar with standard libraries</li> <li>Improves maintainability and upgradability</li> <li>Provides access to community support and documentation</li> <li>Focuses effort on novel aspects of the problem rather than solved ones</li> </ul>"},{"location":"antipatterns/premature-architecture/","title":"Premature Architecture Complexity","text":"<p>When AI assistants create overly complex architectures before fully understanding requirements. They generate impressive-looking full-stack solutions with numerous components, layers, and abstractions that are unnecessary for the actual problem.</p>"},{"location":"antipatterns/premature-architecture/#how-to-spot-it","title":"How to Spot It","text":"<p>Look for these signs:</p> <ul> <li>Complex architecture diagrams or explanations appear before requirements are fully discussed</li> <li>Introduction of multiple layers of abstraction in initial proposals</li> <li>Inclusion of components to handle edge cases that haven't been specified</li> <li>Proposing integration with numerous external systems without clear justification</li> <li>Long explanations of architectural patterns without tying them to specific requirements</li> <li>Using phrases like \"we'll need X, Y, and Z to make this scalable\" before knowing the scale</li> </ul>"},{"location":"antipatterns/premature-architecture/#why-its-harmful","title":"Why It's Harmful","text":"<ul> <li>Wastes time implementing unnecessary features</li> <li>Creates maintenance burden for unused components</li> <li>Makes changes difficult as requirements evolve</li> <li>Obscures core functionality behind abstraction layers</li> <li>Extends development time without adding value</li> </ul>"},{"location":"antipatterns/premature-architecture/#what-to-do-about-it","title":"What to Do About It","text":"<p>When you see this happening:</p> <ol> <li>Say \"Let's pause on the architecture and focus on understanding the core problem first.\"</li> <li>Ask \"Can you provide a minimal version that addresses just these specific requirements?\"</li> <li>Request \"For each component you're proposing, explain what specific requirement it addresses.\"</li> </ol> <p>To prevent it next time:</p> <ol> <li>Set boundaries: \"We need a solution that uses at most X components and can be implemented in Y time.\"</li> <li>Be explicit: \"The priority is solving A, B, and C; everything else is optional.\"</li> <li>Start small: \"Let's build the simplest version first, then iterate.\"</li> <li>Define success: \"Here's how we'll know if the solution is working...\"</li> <li>Apply YAGNI: Remind the AI that \"You Aren't Gonna Need It\" for premature features</li> </ol>"},{"location":"antipatterns/premature-architecture/#example","title":"Example","text":"<p>AI: \"For this contact form, we'll need a React frontend with Redux for state management, a Node.js backend with Express, a MongoDB database, a Redis cache for session management, and we should set up a message queue with RabbitMQ to handle...\"</p> <p>You: \"Let's take a step back. We just need a simple contact form that emails submissions to an address. Can you propose the simplest solution that meets just that need?\"</p>"},{"location":"antipatterns/premature-architecture/#benefits-of-fixing-this","title":"Benefits of Fixing This","text":"<ul> <li>Faster development focused on delivering actual value</li> <li>More maintainable code</li> <li>Better alignment between requirements and implementation</li> <li>Greater flexibility for future changes</li> <li>Reduced complexity for developers</li> </ul>"},{"location":"antipatterns/purpose-drift/","title":"Purpose Drift During Refactoring","text":"<p>When AI assistants lose sight of the original purpose during refactoring. The code undergoes continuous improvements, but these changes gradually disconnect from the original objectives, resulting in a solution that might be \"cleaner\" but no longer addresses the core problem effectively.</p>"},{"location":"antipatterns/purpose-drift/#how-to-spot-it","title":"How to Spot It","text":"<p>Look for these signs:</p> <ul> <li>Multiple successive refactoring suggestions without reconnecting to original goals</li> <li>Increasing complexity without corresponding functional improvements</li> <li>Comments like \"we can improve this further by...\" without justifying the improvements</li> <li>Disappearance of key functionality during \"simplification\"</li> <li>Extended discussions about implementation details with no reference to user needs</li> <li>Inability to explain how a change relates to the original requirements</li> <li>Significant changes to public interfaces without clear benefit</li> </ul>"},{"location":"antipatterns/purpose-drift/#why-its-harmful","title":"Why It's Harmful","text":"<ul> <li>Causes loss of essential functionality</li> <li>Wastes development effort</li> <li>Creates code that's technically \"better\" but functionally worse</li> <li>Extends development time without adding value</li> <li>Produces solutions that drift from user needs</li> <li>Makes it difficult to explain the purpose of code sections</li> </ul>"},{"location":"antipatterns/purpose-drift/#what-to-do-about-it","title":"What to Do About It","text":"<p>When you see this happening:</p> <ol> <li>Say \"Let's step back and remember what problem we're trying to solve.\"</li> <li>Ask \"The original goal was X. How does this refactoring help with that?\"</li> <li>Question: \"What specific improvement will users or developers see from this change?\"</li> <li>Set limits: \"Let's limit our refactoring to areas that directly impact our current goals.\"</li> </ol> <p>To prevent it next time:</p> <ol> <li>Document purpose clearly and revisit it regularly</li> <li>Define specific goals: \"We're refactoring to achieve X, Y, and Z improvements.\"</li> <li>Add checkpoints: After each refactoring step, verify the solution still meets requirements</li> <li>Make connections: For each refactoring, connect it to a specific requirement or pain point</li> <li>Set time limits: \"We'll spend at most X time on refactoring before moving on.\"</li> <li>Apply the \"rule of three\": Wait until you see the same problem three times before refactoring</li> </ol>"},{"location":"antipatterns/purpose-drift/#example","title":"Example","text":"<p>AI: \"Now that we've refactored the data access layer, we should also rework the service layer to use dependency injection, and then update the controller to follow CQRS principles...\"</p> <p>You: \"Before we continue refactoring, let's check if we've maintained the original functionality. The main goal was to fix the bug where users couldn't update their profiles. Does our current solution address that, and is further refactoring necessary for that specific goal?\"</p>"},{"location":"antipatterns/purpose-drift/#benefits-of-fixing-this","title":"Benefits of Fixing This","text":"<ul> <li>Maintains focus on delivering actual value</li> <li>Reduces wasted effort on unnecessary improvements</li> <li>Aligns technical decisions with business outcomes</li> <li>Creates clearer justification for refactoring efforts</li> <li>Makes development progress more predictable</li> <li>Simplifies communication about the purpose of code changes</li> </ul>"},{"location":"antipatterns/separation-of-concerns/","title":"Failure to Separate Concerns","text":"<p>When AI assistants create code that mixes different responsibilities within the same components. Rather than organizing code around clear boundaries of responsibility, the implementation intermingles concerns like business logic, data access, presentation, and error handling, creating tight coupling and dependencies.</p>"},{"location":"antipatterns/separation-of-concerns/#how-to-spot-it","title":"How to Spot It","text":"<p>Look for these signs:</p> <ul> <li>Methods or classes that serve multiple distinct purposes</li> <li>Direct database calls within UI components or business logic</li> <li>Formatting and presentation logic mixed with data processing</li> <li>Error handling scattered throughout the codebase</li> <li>Configuration and environment concerns embedded in business logic</li> <li>Large, complex functions that handle multiple aspects of a process</li> <li>Difficulty explaining what a component's single responsibility is</li> <li>Cross-cutting concerns (logging, authorization) duplicated everywhere</li> </ul>"},{"location":"antipatterns/separation-of-concerns/#why-its-harmful","title":"Why It's Harmful","text":"<ul> <li>Makes maintaining or extending the codebase difficult</li> <li>Increases bugs when changing one aspect affects others</li> <li>Creates testing challenges due to inability to isolate components</li> <li>Reduces code reusability</li> <li>Makes onboarding new developers harder</li> <li>Creates tight coupling that makes changes risky</li> <li>Limits ability to refactor or replace individual components</li> </ul>"},{"location":"antipatterns/separation-of-concerns/#what-to-do-about-it","title":"What to Do About It","text":"<p>When you see this happening:</p> <ol> <li>Ask \"What is the single responsibility of this component?\"</li> <li>Point out \"I notice this class is handling both X and Y. Should we separate these?\"</li> <li>Suggest \"Can we separate the data access from the business logic here?\"</li> <li>Question \"What are the natural boundaries between different concerns in this system?\"</li> </ol> <p>To prevent it next time:</p> <ol> <li>Start with modeling: \"Before coding, let's identify the key abstractions and responsibilities.\"</li> <li>Set architectural patterns: \"We'll follow clean architecture with these specific layers...\"</li> <li>Define interfaces first: \"Let's define the interfaces between components before implementation.\"</li> <li>Apply SOLID principles: \"Each class should have only one reason to change.\"</li> <li>Visualize architecture: Sketch out the separation of concerns before implementation</li> <li>Separate cross-cutting concerns: \"Authentication, logging, etc., should be handled through dedicated mechanisms.\"</li> </ol>"},{"location":"antipatterns/separation-of-concerns/#example","title":"Example","text":"<p>AI: \"Here's the UserController class that handles authentication, retrieves user data from the database, formats it for the UI, and logs all activities...\"</p> <p>You: \"This controller is doing too many things. Let's separate these concerns: authentication should be middleware, data access should be in a repository, formatting in a separate view model or service, and logging through a cross-cutting concern. Can you refactor with these separations?\"</p>"},{"location":"antipatterns/separation-of-concerns/#benefits-of-fixing-this","title":"Benefits of Fixing This","text":"<ul> <li>Creates more maintainable and understandable code</li> <li>Makes testing easier through properly isolated components</li> <li>Allows changing individual parts without affecting others</li> <li>Improves reusability of components</li> <li>Gives a clearer mental model of the system</li> <li>Reduces risk when making changes</li> <li>Creates more natural division of work among team members</li> </ul>"},{"location":"antipatterns/separation-of-concerns/#quick-reference-clean-separation","title":"Quick Reference: Clean Separation","text":"<ol> <li>Presentation Layer: UI components, controllers, view models</li> <li>Application Layer: Use cases, application services, coordination</li> <li>Domain Layer: Business logic, entities, domain services</li> <li>Infrastructure Layer: Data access, external services, technical implementation</li> </ol>"},{"location":"antipatterns/separation-of-concerns/#warning-signs","title":"Warning Signs","text":"<ul> <li>Methods longer than a screen</li> <li>Classes with more than one reason to change</li> <li>Difficulty writing unit tests</li> <li>\"God objects\" that know too much</li> <li>Direct database queries in UI handlers</li> <li>Business logic in presentation components</li> </ul>"},{"location":"antipatterns/test-driven-design/","title":"Test-Driven Design Misapplication","text":"<p>When AI assistants blindly follow existing test patterns as a blueprint for implementation, rather than approaching the problem from first principles. Instead of using tests to verify a thoughtfully designed solution, the implementation becomes constrained by test structure.</p>"},{"location":"antipatterns/test-driven-design/#how-to-spot-it","title":"How to Spot It","text":"<p>Look for these signs:</p> <ul> <li>Implementation that mirrors test structure rather than domain concepts</li> <li>Focusing on passing tests rather than solving the underlying problem</li> <li>Function signatures designed around test mocking rather than usability</li> <li>Excessive code complexity to accommodate test patterns</li> <li>Declarations like \"based on the test, we need to implement it this way\"</li> <li>Heavy emphasis on testing terminology before solution concepts</li> </ul>"},{"location":"antipatterns/test-driven-design/#why-its-harmful","title":"Why It's Harmful","text":"<ul> <li>Creates solutions that satisfy tests but miss the actual problem</li> <li>Produces rigid designs that are difficult to evolve</li> <li>Ties implementation to testing frameworks rather than domain concepts</li> <li>Results in overengineered code just to accommodate testing</li> <li>Loses connection to the original problem statement</li> </ul>"},{"location":"antipatterns/test-driven-design/#what-to-do-about-it","title":"What to Do About It","text":"<p>When you see this happening:</p> <ol> <li>Say \"Let's set aside the tests for a moment and think about how we'd solve this problem naturally.\"</li> <li>Ask \"Why are we structuring the code this way? Is it just to match the tests?\"</li> <li>Refocus: \"What was the original problem we're trying to solve here?\"</li> <li>Suggest: \"If we were designing this from scratch without considering the tests, what would be the clearest approach?\"</li> </ol> <p>To prevent it next time:</p> <ol> <li>Start with the domain: \"Let's model the domain first, then figure out how to test it.\"</li> <li>Separate concerns: \"First we'll design the solution, then we'll figure out how to test it.\"</li> <li>Focus on fundamentals: \"What are the core concepts and operations in this domain?\"</li> <li>Clarify purpose: \"Tests should verify our solution works, not dictate its structure.\"</li> <li>Think from user perspective: \"Let's design this from the user's perspective first.\"</li> </ol>"},{"location":"antipatterns/test-driven-design/#example","title":"Example","text":"<p>AI: \"Based on the test case TestUserRegistration, we need to create a UserRegistrationManager class with these specific methods to make the tests pass...\"</p> <p>You: \"Let's take a step back and think about user registration from first principles. What's the core flow we need to implement? After we understand that, we can figure out how to structure it in a way that's both testable and maintainable.\"</p>"},{"location":"antipatterns/test-driven-design/#benefits-of-fixing-this","title":"Benefits of Fixing This","text":"<ul> <li>Creates designs that better reflect domain concepts</li> <li>Produces more flexible and adaptable code</li> <li>Establishes clearer separation between testing and implementation</li> <li>Focuses on solving problems rather than satisfying tests</li> <li>Makes refactoring easier without breaking tests</li> <li>Creates tests that verify behavior rather than implementation details</li> </ul>"},{"location":"best-practices/","title":"Best Practices for AI-Assisted Coding","text":"<p>This section provides guidelines and patterns for effective collaboration with AI coding assistants. These best practices will help you maintain code quality, manage complexity, and implement robust solutions when working with AI tools.</p>"},{"location":"best-practices/#available-guides","title":"Available Guides","text":""},{"location":"best-practices/#managing-code-complexity","title":"Managing Code Complexity","text":"<p>A comprehensive guide to maintaining optimal code complexity when working with AI coding assistants:</p> <ul> <li>Understanding cyclomatic complexity and its impact</li> <li>Guidelines for optimal code structure</li> <li>Effective prompting techniques for AI assistants</li> <li>Language-specific tools for measuring complexity</li> <li>CI/CD integration for automated complexity checks</li> </ul>"},{"location":"best-practices/#factory-pattern-implementation","title":"Factory Pattern Implementation","text":"<p>A detailed guide to implementing the Factory Pattern for MCP servers with REST API integration:</p> <ul> <li>Core design principles for entity-centric organization</li> <li>Implementation components including abstract base classes</li> <li>Schema definition and validation</li> <li>REST API integration strategies</li> <li>Benefits of the factory-based architecture</li> </ul>"},{"location":"best-practices/#general-principles","title":"General Principles","text":"<p>When working with AI coding assistants, keep these principles in mind:</p> <ol> <li>Maintain control over architecture decisions</li> <li>Use AI for implementation details, not high-level design</li> <li> <p>Validate architectural suggestions against established patterns</p> </li> <li> <p>Verify generated code quality</p> </li> <li>Review all AI-generated code for complexity issues</li> <li> <p>Apply consistent standards to both human and AI-written code</p> </li> <li> <p>Incremental adoption</p> </li> <li>Integrate smaller, well-understood chunks of AI-generated code</li> <li> <p>Build up complexity gradually rather than all at once</p> </li> <li> <p>Continuous learning</p> </li> <li>Document successful patterns for future reference</li> <li> <p>Share effective prompting techniques with your team</p> </li> <li> <p>Balance automation with oversight</p> </li> <li>Automate routine coding tasks with AI</li> <li>Maintain human oversight for critical components</li> </ol>"},{"location":"best-practices/cyclomatic-complexity/","title":"Managing Code Complexity: A Guide for Working with AI Coding Agents","text":""},{"location":"best-practices/cyclomatic-complexity/#introduction","title":"Introduction","text":"<p>This guide provides practical strategies for maintaining optimal code complexity when working with AI coding assistants. It covers complexity metrics, language-specific tools, and prompting techniques to ensure that AI-generated code remains maintainable, testable, and robust.</p>"},{"location":"best-practices/cyclomatic-complexity/#understanding-cyclomatic-complexity","title":"Understanding Cyclomatic Complexity","text":"<p>Cyclomatic complexity measures the number of independent paths through a program's code. It provides a quantitative assessment of code complexity.</p>"},{"location":"best-practices/cyclomatic-complexity/#how-its-calculated","title":"How It's Calculated","text":"<ul> <li>Starting value: 1</li> <li>Add 1 for each:</li> <li><code>if</code> statement</li> <li><code>else if</code> statement</li> <li><code>case</code> in a <code>switch</code></li> <li>Boolean operator (<code>&amp;&amp;</code>, <code>||</code>) in conditions</li> <li>Loop (<code>for</code>, <code>while</code>, <code>do-while</code>)</li> <li><code>catch</code> block</li> </ul>"},{"location":"best-practices/cyclomatic-complexity/#complexity-thresholds","title":"Complexity Thresholds","text":"Complexity Risk Level Recommendation 1-10 Low Ideal target range for most functions 11-20 Moderate Consider refactoring 21-50 High Requires immediate refactoring 50+ Very High Untestable, must be broken down"},{"location":"best-practices/cyclomatic-complexity/#guidelines-for-optimal-code-structure","title":"Guidelines for Optimal Code Structure","text":""},{"location":"best-practices/cyclomatic-complexity/#function-design","title":"Function Design","text":"<ul> <li>Size: Keep functions under 30 lines of code</li> <li>Responsibility: One function = one responsibility</li> <li>Complexity: Target maximum cyclomatic complexity of 10</li> <li>Parameters: Limit to 3-4 parameters per function</li> <li>Return statements: Use early returns for edge cases</li> </ul>"},{"location":"best-practices/cyclomatic-complexity/#conditional-logic","title":"Conditional Logic","text":"<ul> <li>Nesting: Maximum 2-3 levels of nested conditionals</li> <li>Complex conditions: Extract into named helper functions or variables</li> <li>Decision making: Use switch statements instead of long if-else chains</li> <li>Validation: Handle edge cases and validation at the beginning of functions</li> </ul>"},{"location":"best-practices/cyclomatic-complexity/#code-organization","title":"Code Organization","text":"<ul> <li>Modules: Each file should have a clear, single purpose</li> <li>Interfaces: Design clean, minimal public interfaces</li> <li>Dependencies: Reduce coupling between components</li> <li>Patterns: Apply consistent patterns for similar problems</li> </ul>"},{"location":"best-practices/cyclomatic-complexity/#prompting-ai-coding-agents","title":"Prompting AI Coding Agents","text":"<p>When working with AI coding assistants, include these specific instructions in your prompts:</p>"},{"location":"best-practices/cyclomatic-complexity/#general-prompting-template","title":"General Prompting Template","text":"<pre><code>[Describe the task]\n\nPlease follow these complexity guidelines:\n- Keep functions under 30 lines with cyclomatic complexity under 10\n- One function = one responsibility\n- Maximum 2-3 levels of nesting\n- Extract complex conditions into named helper functions\n- Use early returns for validation and edge cases\n- Include brief comments explaining complex logic\n</code></pre>"},{"location":"best-practices/cyclomatic-complexity/#for-refactoring-tasks","title":"For Refactoring Tasks","text":"<pre><code>Please refactor this code to:\n- Break up functions with complexity over 10\n- Extract helper functions for repeated or complex logic\n- Reduce nesting depth\n- Make the code more testable\n</code></pre>"},{"location":"best-practices/cyclomatic-complexity/#for-code-reviews","title":"For Code Reviews","text":"<pre><code>Review this code focusing on complexity issues:\n- Identify functions with high cyclomatic complexity\n- Suggest refactoring for nested conditionals\n- Check for functions with too many responsibilities\n- Look for opportunities to extract helper methods\n</code></pre>"},{"location":"best-practices/cyclomatic-complexity/#language-specific-tools-for-measuring-complexity","title":"Language-Specific Tools for Measuring Complexity","text":""},{"location":"best-practices/cyclomatic-complexity/#python","title":"Python","text":"<ol> <li> <p>Radon - Command-line tool and Python API    <pre><code>pip install radon\nradon cc path/to/file.py --min B\n</code></pre></p> </li> <li> <p>Pylint - Linting with complexity checks    <pre><code>pip install pylint\npylint --max-complexity=10 path/to/file.py\n</code></pre></p> </li> <li> <p>Wily - Tracks complexity over time    <pre><code>pip install wily\nwily build path/to/codebase\nwily report path/to/file.py\n</code></pre></p> </li> </ol>"},{"location":"best-practices/cyclomatic-complexity/#typescriptjavascript","title":"TypeScript/JavaScript","text":"<ol> <li>ESLint with complexity plugin <pre><code>npm install eslint eslint-plugin-complexity\n</code></pre></li> </ol> <p>In <code>.eslintrc.json</code>:    <pre><code>{\n  \"plugins\": [\"complexity\"],\n  \"rules\": {\n    \"complexity\": [\"error\", 10]\n  }\n}\n</code></pre></p> <ol> <li>CodeClimate - Quality monitoring tool</li> <li>Set up through the CodeClimate platform</li> <li> <p>Integrates with GitHub for automated reviews</p> </li> <li> <p>Plato - JavaScript complexity reporting    <pre><code>npm install -g plato\nplato -r -d report path/to/source\n</code></pre></p> </li> </ol>"},{"location":"best-practices/cyclomatic-complexity/#rust","title":"Rust","text":"<ol> <li> <p>Clippy - Official Rust linter    <pre><code>rustup component add clippy\ncargo clippy\n</code></pre></p> </li> <li> <p>Rust-code-analysis - Mozilla's metrics tool    <pre><code>cargo install rust-code-analysis-cli\nrust-code-analysis-cli -p path/to/src -o metrics.json\n</code></pre></p> </li> </ol>"},{"location":"best-practices/cyclomatic-complexity/#cicd-integration","title":"CI/CD Integration","text":"<p>Add complexity checking to your continuous integration pipeline:</p>"},{"location":"best-practices/cyclomatic-complexity/#github-actions-example","title":"GitHub Actions Example","text":"<pre><code>name: Code Quality\n\non: [push, pull_request]\n\njobs:\n  complexity:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.x'\n\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install radon\n\n      - name: Check cyclomatic complexity\n        run: |\n          radon cc --min C . &gt; complexity_report.txt\n          if grep -q \"^[EF]\" complexity_report.txt; then\n            echo \"High complexity code detected:\"\n            cat complexity_report.txt\n            exit 1\n          fi\n</code></pre>"},{"location":"best-practices/cyclomatic-complexity/#best-practices-for-ai-generated-code-review","title":"Best Practices for AI-Generated Code Review","text":"<ol> <li>Immediate review - Always review AI-generated code before integration</li> <li>Complexity check - Run complexity tools on generated code</li> <li>Understanding - Ensure you understand every line generated</li> <li>Test coverage - Write tests that cover all paths through the code</li> <li>Incremental adoption - Integrate smaller, well-understood chunks</li> </ol>"},{"location":"best-practices/cyclomatic-complexity/#conclusion","title":"Conclusion","text":"<p>Maintaining optimal code complexity is crucial for long-term project health. By following these guidelines and using appropriate tools, you can work effectively with AI coding agents to produce clean, maintainable, and robust code.</p> <p>Remember that complexity metrics are guidelines, not strict rules. Balance them with readability, performance requirements, and the specific context of your project.</p>"},{"location":"best-practices/factory-pattern/","title":"Factory Pattern Implementation Guide for MCP Servers with REST API","text":""},{"location":"best-practices/factory-pattern/#core-design-principles","title":"Core Design Principles","text":"<ol> <li> <p>Entity-Centric Organization: Structure your tools around domain entities rather than individual operations.</p> </li> <li> <p>Operation Grouping: Each entity tool should support multiple related operations (list, get, create, update, delete).</p> </li> <li> <p>Factory-Based Creation: Implement a central factory that creates and configures entity tools.</p> </li> <li> <p>Registry-Based Management: Use a tool registry to manage registration, discovery, and execution.</p> </li> <li> <p>Declarative Schema Definition: Define operation parameters using declarative schemas for validation and documentation.</p> </li> </ol>"},{"location":"best-practices/factory-pattern/#implementation-components","title":"Implementation Components","text":""},{"location":"best-practices/factory-pattern/#1-abstract-base-class","title":"1. Abstract Base Class","text":"<pre><code>abstract class EntityTool {\n  protected operations: Record&lt;string, Function&gt; = {};\n  protected schemas: Record&lt;string, Schema&gt; = {};\n\n  // Register operations with their validation schemas\n  protected registerOperation(name: string, handler: Function, schema: Schema): void {\n    this.operations[name] = handler;\n    this.schemas[name] = schema;\n  }\n\n  // Execute operations with validation\n  public async execute(args: any): Promise&lt;any&gt; {\n    const operation = args.operation;\n    const params = args[`${operation}Params`];\n\n    // Validate params using schema\n    const validParams = this.schemas[operation].parse(params);\n\n    // Execute operation\n    return this.operations[operation](validParams);\n  }\n\n  // Generate documentation\n  public getDocumentation(): Documentation {\n    // Implementation\n  }\n}\n</code></pre>"},{"location":"best-practices/factory-pattern/#2-entity-tool-factory","title":"2. Entity Tool Factory","text":"<pre><code>class EntityToolFactory {\n  // Create instance of UsersTool\n  static createUsersTool(apiClient: ApiClient): UsersTool {\n    return new UsersTool(apiClient);\n  }\n\n  // Create instance of ResourcesTool\n  static createResourcesTool(apiClient: ApiClient): ResourcesTool {\n    return new ResourcesTool(apiClient);\n  }\n\n  // Other factory methods...\n}\n</code></pre>"},{"location":"best-practices/factory-pattern/#3-entity-specific-tools","title":"3. Entity-Specific Tools","text":"<pre><code>class UsersTool extends EntityTool {\n  private apiClient: ApiClient;\n\n  constructor(apiClient: ApiClient) {\n    super();\n    this.apiClient = apiClient;\n\n    // Register operations\n    this.registerOperation('list', this.listUsers, listSchema);\n    this.registerOperation('get', this.getUser, getSchema);\n    this.registerOperation('create', this.createUser, createSchema);\n    this.registerOperation('update', this.updateUser, updateSchema);\n    this.registerOperation('delete', this.deleteUser, deleteSchema);\n  }\n\n  private async listUsers(params: ListUsersParams): Promise&lt;User[]&gt; {\n    const response = await this.apiClient.get('/users', params);\n    return response.data.map(userData =&gt; this.mapToUser(userData));\n  }\n\n  private async getUser(params: GetUserParams): Promise&lt;User&gt; {\n    const response = await this.apiClient.get(`/users/${params.userId}`);\n    return this.mapToUser(response.data);\n  }\n\n  private async createUser(params: CreateUserParams): Promise&lt;User&gt; {\n    const response = await this.apiClient.post('/users', params);\n    return this.mapToUser(response.data);\n  }\n\n  private async updateUser(params: UpdateUserParams): Promise&lt;User&gt; {\n    const response = await this.apiClient.put(`/users/${params.userId}`, params);\n    return this.mapToUser(response.data);\n  }\n\n  private async deleteUser(params: DeleteUserParams): Promise&lt;void&gt; {\n    await this.apiClient.delete(`/users/${params.userId}`);\n  }\n\n  private mapToUser(data: any): User {\n    // Convert API response to User entity\n    return {\n      id: data.id,\n      username: data.username,\n      email: data.email,\n      role: data.role,\n      properties: data.properties || {}\n    };\n  }\n}\n</code></pre>"},{"location":"best-practices/factory-pattern/#4-tool-registry","title":"4. Tool Registry","text":"<pre><code>class ToolRegistry {\n  private tools: Map&lt;string, EntityTool&gt; = new Map();\n\n  constructor(apiClient: ApiClient) {\n    // Initialize and register tools\n    this.registerTool('users', EntityToolFactory.createUsersTool(apiClient));\n    this.registerTool('resources', EntityToolFactory.createResourcesTool(apiClient));\n    // Register other tools...\n  }\n\n  public registerTool(name: string, tool: EntityTool): void {\n    this.tools.set(name, tool);\n  }\n\n  public async executeTool(name: string, args: any): Promise&lt;any&gt; {\n    const tool = this.tools.get(name);\n\n    if (!tool) {\n      throw new Error(`Tool '${name}' not found`);\n    }\n\n    try {\n      return await tool.execute(args);\n    } catch (error) {\n      // Enhanced error handling\n      throw this.enhanceError(error, name, args);\n    }\n  }\n\n  public getToolNames(): string[] {\n    return Array.from(this.tools.keys());\n  }\n\n  public getToolDocumentation(name: string): Documentation {\n    const tool = this.tools.get(name);\n\n    if (!tool) {\n      throw new Error(`Tool '${name}' not found`);\n    }\n\n    return tool.getDocumentation();\n  }\n\n  private enhanceError(error: any, toolName: string, args: any): Error {\n    // Add context to error\n    error.toolName = toolName;\n    error.args = args;\n    return error;\n  }\n}\n</code></pre>"},{"location":"best-practices/factory-pattern/#rest-api-integration","title":"REST API Integration","text":""},{"location":"best-practices/factory-pattern/#apiclient-implementation","title":"ApiClient Implementation","text":"<pre><code>class ApiClient {\n  private baseUrl: string;\n  private authToken: string;\n\n  constructor(baseUrl: string, authToken: string) {\n    this.baseUrl = baseUrl;\n    this.authToken = authToken;\n  }\n\n  async get(path: string, queryParams?: object): Promise&lt;any&gt; {\n    return this.request('GET', path, queryParams);\n  }\n\n  async post(path: string, data?: object): Promise&lt;any&gt; {\n    return this.request('POST', path, null, data);\n  }\n\n  async put(path: string, data?: object): Promise&lt;any&gt; {\n    return this.request('PUT', path, null, data);\n  }\n\n  async delete(path: string): Promise&lt;any&gt; {\n    return this.request('DELETE', path);\n  }\n\n  private async request(method: string, path: string, queryParams?: object, data?: object): Promise&lt;any&gt; {\n    try {\n      const url = new URL(this.baseUrl + path);\n\n      // Add query parameters\n      if (queryParams) {\n        Object.entries(queryParams).forEach(([key, value]) =&gt; {\n          url.searchParams.append(key, String(value));\n        });\n      }\n\n      const response = await fetch(url.toString(), {\n        method,\n        headers: {\n          'Authorization': `Bearer ${this.authToken}`,\n          'Content-Type': 'application/json',\n          'Accept': 'application/json'\n        },\n        body: data ? JSON.stringify(data) : undefined\n      });\n\n      if (!response.ok) {\n        throw await this.handleErrorResponse(response);\n      }\n\n      return await response.json();\n    } catch (error) {\n      throw this.enhanceNetworkError(error, method, path);\n    }\n  }\n\n  private async handleErrorResponse(response: Response): Promise&lt;Error&gt; {\n    let errorData: any;\n\n    try {\n      errorData = await response.json();\n    } catch {\n      errorData = { message: 'Unknown error' };\n    }\n\n    const error = new Error(errorData.message || `HTTP Error ${response.status}`);\n    error.statusCode = response.status;\n    error.responseData = errorData;\n\n    return error;\n  }\n\n  private enhanceNetworkError(error: any, method: string, path: string): Error {\n    error.request = { method, path };\n    return error;\n  }\n}\n</code></pre>"},{"location":"best-practices/factory-pattern/#pagination-support","title":"Pagination Support","text":"<pre><code>class PaginationHelper {\n  static async fetchAllPages&lt;T&gt;(fetchPage: (page: number) =&gt; Promise&lt;{data: T[], totalPages: number}&gt;): Promise&lt;T[]&gt; {\n    const result: T[] = [];\n    let currentPage = 1;\n    let totalPages = 1;\n\n    do {\n      const response = await fetchPage(currentPage);\n      result.push(...response.data);\n      totalPages = response.totalPages;\n      currentPage++;\n    } while (currentPage &lt;= totalPages);\n\n    return result;\n  }\n}\n</code></pre>"},{"location":"best-practices/factory-pattern/#schema-definition-examples","title":"Schema Definition Examples","text":""},{"location":"best-practices/factory-pattern/#zod-schema-examples","title":"Zod Schema Examples","text":"<pre><code>import { z } from 'zod';\n\n// User schemas\nconst listUsersSchema = z.object({\n  page: z.number().int().positive().optional(),\n  pageSize: z.number().int().positive().max(100).optional(),\n  filter: z.string().optional()\n});\n\nconst getUserSchema = z.object({\n  userId: z.string().uuid()\n});\n\nconst createUserSchema = z.object({\n  username: z.string().min(3).max(50),\n  email: z.string().email(),\n  role: z.enum(['admin', 'user', 'guest']).optional(),\n  properties: z.record(z.string(), z.any()).optional()\n});\n\nconst updateUserSchema = z.object({\n  userId: z.string().uuid(),\n  username: z.string().min(3).max(50).optional(),\n  email: z.string().email().optional(),\n  role: z.enum(['admin', 'user', 'guest']).optional(),\n  properties: z.record(z.string(), z.any()).optional()\n});\n\nconst deleteUserSchema = z.object({\n  userId: z.string().uuid()\n});\n</code></pre>"},{"location":"best-practices/factory-pattern/#complete-system-initialization","title":"Complete System Initialization","text":"<pre><code>function initializeSystem(baseUrl: string, authToken: string) {\n  // Create API client\n  const apiClient = new ApiClient(baseUrl, authToken);\n\n  // Create tool registry and register tools\n  const toolRegistry = new ToolRegistry(apiClient);\n\n  return {\n    // Execute a tool operation\n    async execute(toolName: string, operation: string, params: any) {\n      return toolRegistry.executeTool(toolName, {\n        operation,\n        [`${operation}Params`]: params\n      });\n    },\n\n    // Get list of available tools\n    getToolNames() {\n      return toolRegistry.getToolNames();\n    },\n\n    // Get documentation for a tool\n    getToolDocumentation(toolName: string) {\n      return toolRegistry.getToolDocumentation(toolName);\n    }\n  };\n}\n\n// Usage example\nconst system = initializeSystem('https://api.example.com', 'auth-token-123');\n\n// List users\nconst users = await system.execute('users', 'list', { page: 1, pageSize: 10 });\n\n// Create a user\nconst newUser = await system.execute('users', 'create', {\n  username: 'johndoe',\n  email: 'john@example.com',\n  role: 'user'\n});\n</code></pre>"},{"location":"best-practices/factory-pattern/#benefits-of-this-architecture","title":"Benefits of This Architecture","text":"<ol> <li> <p>Reduced Complexity: Instead of dozens of individual tools (one per operation), you have a handful of entity tools with multiple operations.</p> </li> <li> <p>Intuitive Organization: Tools are organized by the entities they operate on, making them more discoverable and easier to understand.</p> </li> <li> <p>Consistent Interface: All entity tools follow the same pattern for operations and parameters, providing a consistent user experience.</p> </li> <li> <p>Better Error Handling: Each entity tool can handle errors specific to its domain, providing more meaningful error messages.</p> </li> <li> <p>Enhanced Documentation: Entity tools can provide rich documentation with examples and operation-specific descriptions.</p> </li> <li> <p>Simplified Maintenance: Adding new operations to an entity is easier than creating entirely new tools.</p> </li> <li> <p>Testability: The architecture lends itself well to unit testing and dependency injection.</p> </li> </ol>"},{"location":"best-practices/factory-pattern/#implementation-guidelines","title":"Implementation Guidelines","text":"<p>When implementing this pattern:</p> <ol> <li> <p>Start with Domain Entities: Identify the key entities in your domain (Users, Resources, etc.).</p> </li> <li> <p>Define Operations: For each entity, define the operations it supports (list, get, create, etc.).</p> </li> <li> <p>Create Base Class: Implement a base class with common functionality for all entity tools.</p> </li> <li> <p>Implement Factory: Create a factory class with methods to create each entity tool.</p> </li> <li> <p>Create Registry: Implement a registry to manage tool registration and execution.</p> </li> <li> <p>Add Documentation: Provide rich documentation with examples and operation-specific descriptions.</p> </li> <li> <p>Handle Errors: Implement comprehensive error handling with meaningful error messages.</p> </li> </ol> <p>This architectural pattern provides a maintainable, user-friendly, and robust approach to implementing MCP servers with REST API integration.</p>"}]}